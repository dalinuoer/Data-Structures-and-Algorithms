/*
* 散列（hash）的定义与整数散列
* Author: Qin Hao
* Date: 2020/5/1
*/

// 可以直接把输入的数作为数组的下标来对这个数的性质进行统计，这种做法非常实用，务必掌握。

// 但是，如果输入的数字过大，或者甚至是一个字符串，就不能把它们作为数组下标了。
// 此时可以“将元素通过一个函数转换为整数，使得该整数可以尽量唯一的代表这个元素”，这就是“散列”。
// 这个转换函数称为“散列函数H”。

// 对key是整数的情况来说，常用的散列函数有 直接定址法、平方取中法、除留余数法 等。
// 直接定址法是指恒等变换（即H（key） = key）或是线性变换（即H（key） = a * key + b）；
// 平方取中法是指取key的平方的中间若干位作为hash值；
// 比较实用的是除留余数法。

// 除留余数法是指把key除以一个数mod得到的余数作为hash值的方法，即 H（key） = key % mod
// 注意：表长TSize必须不小于mod，不然会产生越界
// 当mod是一个素数时，H（key）能尽可能覆盖[0, mod）范围内每一个数
// 所以，一般取 TSize 是一个素数，mod = TSise

// 存在“冲突”现象，解决方法有 3 种，前 2 种属于开放定址法
// 1. 线性探查法：若某位置已被占用，则依次寻找下一个位置，直到找到空位置为止；容易扎堆，降低效率
// 2. 平方探查法：当下标为H（key）的位置已被占用，则按照H（key）+ 1^2，H（key）- 1^2，H（key）+ 2^2
//              H（key）- 2^2 ... 的顺序检查，直到找到空位置。
//              若出现H（key）- k^2 < 0的情况，那么将（（H（key）- k^2）% TSize + TSize）% TSize 作为结果
//              还可以只进行正向探查
// 3. 链地址法（拉链法）：此方法不重新计算新的hash值，而是把所有hash值相同的key连接成一条单链表。
//                     思想是“让一个位置存放多个key”。

// C++11 STL 中可以借助 unordered_map （C++11 之前可用map）直接使用hash功能，
// 除非必须模拟这些方法或对算法效率要求比较高，否则一般不要自己实现上面的解决冲突的方法

// map 可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）
