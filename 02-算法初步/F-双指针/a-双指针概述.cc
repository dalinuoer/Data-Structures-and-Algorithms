/*
* 双指针概述
* Author: Qin Hao
* Date: 2020/6/24
*/

// 给定一个**递增**的正整数序列和一个正整数 M，求序列中两个位置的数 a 和 b，使它们的和为 M，
// 输出所有满足条件的方案。

// 一个方案是使用二重循环，遍历枚举，时间复杂度为 O(n^2)，对 n 在 10^5 的规模是不可承受的。
// 复杂度高的一个重要原因是进行了大量无效的枚举。
// 双指针法借助有序序列的枚举特性有效降低复杂度。

// 代码如下：
int i = 0, j = len - 1; // 初始值
while (i < j)
{
    if (a[i] + a[j] == m) // 满足条件
    {
        printf("%d %d", a[i], a[j]);
        ++i;
        --j;
    }
    else if (a[i] + a[j] < m)
    {
        ++i;
    }
    else if (a[i] + a[j] > m)
    {
        --j;
    }
}

// 时间复杂度为 O(n)

// 序列合并问题
// 假设有两个递增的序列 A 和 B，要求将他们合并为一个递增的序列 C。

// 代码如下：
int merge(int A[], int B[], int C[], int n, int m)
{
    int i = 0, j = 0, index = 0; // i 指向 A[0]，j 指向 B[0]
    while (i < n && j < m)
    {
        if (A[i] <= B[j])
        {
            C[index++] = A[i++]; // 将 A[i] 加入序列 C
        }
        else
        {
            C[index++] = B[j++]; // 将 B[j] 加入序列 C
        }
    }
    // 将剩余元素加入序列 c
    while (i < n) C[index++] = A[i++];
    while (j < m) C[index++] = B[j++];
    // 返回序列 C 的长度
    return index;
}

// 双指针的思想：
// 事实上，双指针最原始的含义就是针对第一个问题的，而广义上的双指针则是利用问题本身与序列
// 的特性，使用两个下标 i 和 j 对序列进行扫描，以较低的复杂度（一般是O(n)）解决问题。