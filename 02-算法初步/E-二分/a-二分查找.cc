/*
* 二分查找
* Author: Qin Hao
* Date: 2020/5/25
*/

// 如何在一个严格递增（或递减）的序列 A 中找出给定的数 x
// 解决这个问题的一种常见方法是顺序遍历，时间复杂度为 O(n)，当查询次数不多时这个方法还是挺好的
// 但是如果规模很大的时候这种方法就不是很好了，一种更好的方法是使用 二分查找

// 二分查找是基于 有序序列 的查找算法（这一点很重要）
// 假设该序列为 严格递增 的
// 该算法一开始令 [left, right] 为整个序列的下标空间，
// 然后每次测试当前区间的中间位置 mid = (left + right) / 2
// 判断 A[mid] 与欲查询元素 x 的大小
// 1. 若 A[mid] == x，说明查找成功，退出查询；
// 2. 若 A[mid] > x，说明元素 x 在 mid 的左边，因此往左子区间 [left, mid - 1] 继续查找；
// 3. 若 A[mid] < x，说明元素 x 在 mid 的右边，因此往右子区间 [mid + 1, right] 继续查找。

// 二分查找的高效之处在于,每一步都可以去除当前区间中的一半元素,因此其时间复杂度为 O(log n),这是十分优秀的.

#include <cstdio>

int binarySearch(int a[], int len, int x)
{
    int left = 0, right = len - 1;
    while (left <= right) // 序列是递增的
    {
        int mid = (left + right) / 2; // mid 为序列中点
        if (a[mid] == x) // 找到 x 位置,返回下标
        {
            return mid;
        }
        else if (a[mid] > x) // 中间数大于 x,往左子区间查找
        {
            right = mid - 1;
        }
        else // 中间数小于 x,往右子区间查找
        {
            left = mid + 1;
        }
    }
    return -1; // 查找失败,返回 -1
}

// 注意:
// 1. 若序列式递减的,则只需修改代码,将 A[mid] > x,改成 A[mid] < x 即可;
// 2. 若二分上界超过 int 型数据范围的一半,那么当与查询元素在序列较靠后位置时,
// 语句 mid = (left + right) / 2 中的 left + right 就有可能超过 int 而导致溢出,
// 此时一般使用 mid = left + (right - left) /2 这条等价语句作为代替以避免溢出;
// 3. 二分法可使用递归进行实现,但是在进行程序设计时更多地采用的是非递归的写法;
// 4. 若初始序列中元素不重复,但是无序,则可先进行排序,然后使用二分法.

// 若递增序列 A 中的元素是可以重复的,那么如何对给定的欲查询元素 x,
// 1. 求出序列中第一个大于等于 x 的元素位置 L,
// 2. 第一个大于 x 的元素位置 R,
// 这样元素 x 在序列中存在的区间就是左闭右开区间 [L, R).

// 这个问题最容易想到的办法就是顺序遍历,但还是那个问题,一旦规模比较大的话开销就会非常大
// 其实这个问题的两个要求都在解决一件事: 寻找有序序列中第一个满足某条件的元素位置.
// 这是一个非常重要且经典的问题,平时能碰到的大部分二分法问题都可以归结到这个问题.这样的问题有固定的模板

// 解决"寻找有序序列第一个满足某条件的元素的位置"问题的固定模板
// 二分区间为左闭右闭的 [left, right],初值必须能覆盖解的所有可能取值
// 下界为 0, 上界为 n
int solve(int a[], int left, int right, int x)
{
    int mid; // mid 为 left 和 right 的中点
    while (left < right) // 对 [left, right] 来说,left == right意味着找到唯一位置
    {
        mid = (left + right) / 2; // 取中点
        if (条件成立) // 条件成立,第一个满足条件的元素位置 <= mid
        {
            right = mid; // 往左子区间[left, mid]查找
        }
        else // 条件不成立,则第一个满足条件的元素位置 > mid
        {
            left = mid + 1; // 往右子区间[mid + 1, right]查找
        }
    }
    return left; // 返回夹出来的位置
}

// 解决"寻找有序序列第一个满足某条件的元素的位置"问题的固定模板
// 二分区间为左开右闭的 (left, right],
// 初值必须能覆盖解的所有可能取值,且 left 比最小值小一
// 下界为 -1, 上界为 n
int solve(int a[], int left, int right, int x)
{
    int mid; // mid 为 left 和 right 的中点
    while (left + 1 < right) // 对 (left, right] 来说,left + 1 == right意味着找到唯一位置
    {
        mid = (left + right) / 2; // 取中点
        if (条件成立) // 条件成立,第一个满足条件的元素位置 <= mid
        {
            right = mid; // 往左子区间[left, mid]查找
        }
        else // 条件不成立,则第一个满足条件的元素位置 > mid
        {
            left = mid; // 往右子区间[mid, right]查找
        }
    }
    return right; // 返回夹出来的位置
}

// 若想寻找最后一个满足"条件C"的元素位置,则可先求第一个满足"条件!C"的元素位置,然后将该位置减一即可

// 另,若目的是查找 "序列中是否存在满足条件的元素",那么使用开始的二分查找法最为合适.