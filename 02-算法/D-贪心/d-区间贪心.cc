/*
* 区间贪心
* Author: Qin Hao
* Date: 2020/5/9
*/

// 区间不相交问题：给出N个开区间（x， y），从中选择尽可能多的开区间，使得这些开区间两两没有交集。
// 首先考虑最简单的情况,如果开区间I1被开区间I2包含,那么显然选择I1是最好的选择,
// 因为如果选择I1,那么就有更大的空间去容纳其他开区间。
// 接下来把所有开区间按左端点x从大到小排序,如果去除掉区间包含的情况,那么一定有y1>y2>…>yn成立。
// 现在考虑应当如何选取区间。通过观察会发现,I1的右边有一段是一定不会和其他区间重叠的,如果把它去掉,
// 那么I1的左边剩余部分就会被I2包含,此时应当选择I1。因此对这种情况,总是先选择左端点最大的区间。

#include <cstdio>
#include <algorithm>

using namespace std;

const int maxn = 110;

struct Inteval {
    int x, y; // 开区间左右端点
} I[maxn];

bool cmp(Inteval a, Inteval b)
{
    if (a.x != b.x)
    {
        return a.x > b.x; // 先按左端点从大到小排序
    }
    else
    {
        return a.y < b.y; // 左端点相同的按右端点从小到大排序
    }
}

int main(int argc, char **argv)
{
    int n;
    while (scanf("%d", &n), n != 0)
    {
        for (int i = 0; i < n; ++i)
        {
            scanf("%d %d", &I[i].x, &I[i].y);
        }
        sort(I, I + n, cmp); // 排序
        // ans 记录不相交区间个数，lastX记录上一个被选中的区间的左端点
        int ans = 1, lastX = I[0].x;
        for (int i = 1; i < n; ++i)
        {
            if (I[i].y <= lastX) // 该区间右端点在lastX左边
            {
                lastX = I[i].x;
                ++ans;
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}

// 值得注意的是，总是先选择右端点最小的区间的策略也是可行的。

// 与这个问题类似的是区间选点问题：给出N个闭区间[x，y]，求最少需要确定多少个点，才能使每个闭区间中都至少存在一个点。
// 例如对闭区间[1，4]、[2，6]、[5，7]来说，需要两个点（例如3、5）才能保证每个闭区间内都有至少有一个点。

// 事实上，这个问题和区间不相交问题的策略是一致的。
// 首先，如果闭区间I1被闭区间I2包含，那么在I1中取点可以保证这个点一定在I2内。
// 接着把所有区间按左端点从大到小排序，去除掉区间包含的情况。显然，由于每个闭区间中都需要存在一个点，
// 因此对左端点最大的区间I1来说，取哪个点可以让它尽可能多地覆盖其他区间?很显然，只要取左端点即可，
// 这样这个点就能覆盖到尽可能多的区间。
// 区间选点问题的代码只需要把区间不相交问题代码中的“I[i].y<=lastX”改为“Ii].y<lastX”即可。

// 总的来说，贪心是用来解决一类最优化问题，并希望由局部最优策略来推得全局最优结果的算法思想。
// 贪心算法适用的问题一定满足最优子结构性质，即一个问题的最优解可以由它的子问题的最优解有效地构造出来。
// 显然，不是所有问题都适合使用贪心法，但是这并不妨碍贪心算法成为一个简洁、实用、高效的算法。