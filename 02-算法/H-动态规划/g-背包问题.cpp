/**
 * @file g-背包问题.cpp
 * @author Qin Hao (qinhao2020@foxmail.com)
 * @brief 
 * @version 0.1
 * @date 2021-02-21
 * 
 * @copyright Copyright (c) 2021 Qin Hao
 * 
 */

// ------ 1. 多阶段动态规划问题 ------

// 有一类动态规划可解的问题，它可以被描述成若干个有序的阶段，且每个阶段的状态只和上一个阶段的状态
// 有关，一般把这类问题称为多阶段动态规划问题。

// ------ 2. 01背包问题(重点) ------

// 有 n 件物品，每件物品的重量为 w[i]，价值为 c[i]。现有一个容量为 V 的背包，问如何选取物品
// 放入背包，使得背包内物品的总价值最大。其中每件物品都只有一件。

// 如果采取暴力枚举每一件物品放或者不放进背包，显然每件物品都有两种选择，因此 n 件物品就有 2^n
// 种情况，而 O(n^2) 的时间复杂度是不可接受的。

// 使用动态规划的方法可使时间复杂度将至 O(nV)
// 令 dp[i][v] 表示前 i 件物品恰好装入容量为 v 的背包中能获得的最大价值。
// 考虑对第 i 件物品的选择策略，有两种：
// ① 不放第 i 件物品，那么问题转化为前 i-1 件物品恰好装入容量为 v 的背包中所能获得的最大价值，
// 即 dp[i][v] = dp[i - 1][v]
// ② 放第 i 件物品，那么问题转化为前 i-1 件物品恰好装入容量为 v-w[i] 的背包中所能获得的最大价值，
// 即 dp[i][v] = dp[i - 1][v - w[i]] + c[i]
// 状态转移方程显然
// 边界：dp[0][v] = 0
for (int i = 1; i <= n; ++i)
{
    for (int v = w[i]; v <= V; ++v)
    {
        dp[i][v] = max(dp[i - 1][v], dp[i - 1][v - w[i]] + c[i]);
    }
}

// 时间复杂度已经不能再优化，空间复杂度还可以再努力
// 观察状态转移方程，dp[i][] 与 dp[i - 1][] 有关，因此可以只使用一个一维数组
// 状态转移方程修改为：dp[v] = max{ dp[v], dp[v - w[i]] + c[i] }
// 滚动数组
for (int i = 1; i <= n; ++i)
{
    for (int v = V; v >= w[i]; --v) // 逆序枚举 v
    {
        dp[v] = max(dp[v], dp[v - w[i]] + c[i]);
    }
}
// 这样空间复杂度将为 O(V)

// 注意：如果使用二维数组存放，v 的枚举是顺序还是逆序都无所谓；如果使用一维数组存放，则 v 的枚举必须是逆序

#include <cstdio>
#include <algorithm>

using namespace std;

const int maxn = 100;
const int maxv = 1000;
int w[maxn], c[maxn], dp[maxv];

int main(int argc, char **argv)
{
    // 数据输入
    int n, V;
    scanf("%d %d", &n, &V);
    for (int i = 0; i < n; ++i)
    {
        scanf("%d", &w[i]);
    }
    for (int i = 0; i < n; ++i)
    {
        scanf("%d", &c[i]);
    }
    // 边界
    for (int v = 0; v <= V; ++v)
    {
        dp[v] = 0;
    }
    // 状态转移
    for (int i = 1; i <= n; ++i)
    {
        for (int v = V; v >= w[i]; --v)
        {
            dp[v] = max(dp[v], dp[v - w[i]] + c[i]);
        }
    }
    // 输出结果
    int ans = 0;
    for (int v = 0; i <= V; ++v)
    {
        if (dp[v] > ans)
        {
            ans = dp[v];
        }
    }
    printf("%d\n", ans);

    return 0;
}

// 01背包中的每个物品都可以看做一个阶段，这个阶段中的状态有 dp[i][0] - dp[i][V]，它们均由
// 上一个阶段的状态得到。

// 事实上，对能够划分阶段的问题来说，都可以尝试把阶段作为状态的一维，这样就可以使我们更方便地得到
// 满足无后效性的状态。

// 如果当前设计的状态不满足无后效性，那么不妨把状态进行升维，即增加一维或若干维来表示相应的信息，
// 这样可能就满足无后效性了。

// ------ 2. 完全背包问题 ------

// 有 n 种物品，每种物品的单件重量为 w[i]，价值为 c[i]。现在有一个容量为 V 的背包，问，如何
// 选取物品放入背包，使得背包内物品的总价值最大，其中每件物品都有无穷件。

// 令 dp[i][v] 表示前 i 件物品恰好装入容量为 v 的背包中能获得的最大价值。
// 考虑对第 i 件物品的选择策略，有两种：
// ① 不放第 i 件物品，那么问题转化为前 i-1 件物品恰好装入容量为 v 的背包中所能获得的最大价值，
// 即 dp[i][v] = dp[i - 1][v]
// ② 放第 i 件物品，那么问题转化为前 i-1 件物品恰好装入容量为 v-w[i] 的背包中所能获得的最大价值，
// 即 dp[i][v] = dp[i][v - w[i]] + c[i]

// 状态转移方程为：dp[i][v] = max{ dp[i - 1][v], dp[i][v - w[i]] + c[i] }
// 状态转移方程修改为：dp[v] = max{ dp[v], dp[v - w[i]] + c[i] }
// 边界：dp[0][v] = 0

for (int i = 1; i <= n; ++i)
{
    for (int v = w[i]; v <= V; ++v) // 顺序枚举 v
    {
        dp[v] = max(dp[v], dp[v - w[i]] + c[i]);
    }
}
