/**
 * @file e-最长回文子串.cpp
 * @author Qin Hao (qinhao2020@foxmail.com)
 * @brief 
 * @version 0.1
 * @date 2021-02-21
 * 
 * @copyright Copyright (c) 2021 Qin Hao
 * 
 */

// 给出一个字符串 S，求 S 的最长回文子串的长度。

// 还是先看暴力解法：
// 枚举子串的两个端点 i 和 j，判断在 [i, j] 区间内的子串是否是回文。
// 从复杂度上看，枚举端点需要 O(n^2)，判断回文需要 O(n)，因此总的复杂度是 O(n^3)。
// 虽然终于不是指数级别的了，但是在数据规模很大的情况下仍然不够看。

// 看到这，可能会想到一种解法：把字符串 S 倒过来变成字符串 T，然后对 S 和 T 进行 LCS 模型求解，
// 这样就把这个问题转换为最长公共子序列问题来求解，得到的结果就是需要的答案。
// 很遗憾，这个想法是行不同的。因为一旦 S 中同时存在一个子串和它的倒序，那么答案就会出错。

// 接下来介绍动态规划的解法，时间复杂度为 O(n^2)：
// 令 dp[i][j] 表示 S[i] 至 S[j] 所表示的子串是否是回文子串，是则为 1，不是为 0。
// 这样根据 S[i] 是否等于 S[j]，可以把情况分为两类：
// ① 若 S[i] == S[j]，那么只要 S[i + 1] 至 S[j - 1] 是回文子串，则 S[i] 至 S[j] 就是回文子串
// ② 若 S[i] != S[j]，那么 S[i] 至 S[j] 就一定不是回文子串

// 状态转移方程 dp[i][j] = dp[i + 1][j - 1], S[i] == S[j]
//                       0               , S[i] != S[j]
// 边界 dp[i][i] = 1, dp[i][i + 1] = (S[i] == S[i + 1]) ? 1 : 0 （长度为 1 和 2 的子串）

// 还存在一个问题：如果按照 i 和 j 从小到大的顺序来枚举子串的两个端点，然后更新 dp[i][j]，
// 会无法保证 dp[i + 1][j - 1] 已经被计算过，从而无法得到正确的 dp[i][j]

// 根据递推写法从边界出发的原理，注意到边界表示的是长度为 1 和 2 的子串，且每次转移时都对子串的
// 长度减了 1，因此不妨考虑按照子串的长度和子串的初始位置进行枚举，即第一遍将长度为 3 的子串的
// dp 值全部求出，第二遍通过第一遍结果计算出长度为 4 的字串的 dp 值。。。
// 这样就可以避免状态无法转移的问题

#include <cstdio>
#include <cstring>

using namespace std;

const int maxn = 1010;
char S[maxn];
int dp[maxn][maxn];

int main(int argc, char **argv)
{
    // 读取数据，初始化
    gets(S);
    int len = strlen(S);
    int ans = 1;
    memset(dp, 0, sizeof(dp));

    // 边界
    for (int i = 0; i < len; ++i)
    {
        dp[i][i] = 0;
        if (i < len - 1)
        {
            if (S[i] == S[i + 1])
            {
                dp[i][i + 1] = 1;
                ans = 2;
            }
        }
    }

    // 状态转移方程
    for (int L = 3; L <= len; ++L) // 枚举子串的长度
    {
        for (int i = 0; i + L - 1 < len; ++i) // 枚举子串的起始端点
        {
            int j = i + L - 1; // 子串的右端点
            if (S[i] == S[j] && dp[i + 1][j - 1] == 1)
            {
                dp[i][j] = 1;
                ans = L;
            }
        }
    }

    printf("%d\n", ans);

    return 0;
}

// 除了这种方法，还有一些其他的做法
// 二分 + 字符串 hash 的做法，复杂度为 O(nlogn)
// Manacher 算法，复杂度为 O(n)