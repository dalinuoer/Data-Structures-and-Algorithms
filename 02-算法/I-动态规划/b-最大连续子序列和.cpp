/**
 * @file b-最大连续子序列和.cpp
 * @author Qin Hao (qinhao2020@foxmail.com)
 * @brief 
 * @version 0.1
 * @date 2021-02-21
 * 
 * @copyright Copyright (c) 2021 Qin Hao
 * 
 */

// 给定一个数字序列 A1,A2,...,An，求 i，j（i<=j<=n），使得 Ai+...+Aj 最大，输出最大和。

// 1. 这个问题如果使用暴力来做，枚举左端点和右端点，需要 O(n^2) 的复杂度，而计算子序和又需要 O(n)
// 的复杂度，总复杂度为 O(n^3).
// 2. 如果采用记录前缀和的方法使计算子序和的时间变为 O(1)，总复杂度仍有 O(n^2)。
// 以上两种方法对于 10^5 大小规模的数据是无法承受的。

// 下面介绍动态规划的做法，复杂度为 O(n)
// 1. 令状态 dp[i] 表示以 A[i] 作为末尾的连续序列的最大和。所以所有子序列的最大和就是数组 A 的最大元素。
// 2. 下面求解 dp 数组。做如下考虑：因为 dp[i] 要求是必须以 A[i] 结尾的连续序列，那么只有两种情况：
// ① 这个最大和连续序列只有一个元素，即以 A[i] 开始和结尾
// ② 这个最大和连续序列有多个元素，即从前面某处 A[p] 开始，一直到 A[i] 结尾
// 对第一种情况，最大和就是 A[i]
// 对第二种情况，最大和是 dp[i - 1] + A[i]，即 A[p] + A[p + 1] +...+ A[i] = dp[i - 1] + A[i]

// 状态转移方程 dp[i] = max{ A[i], dp[i - 1] + A[i] }
// 边界 dp[0] = A[0]

#include <cstdio>
#include <algorithm>

using namespace std;

const int maxn = 10010;
int A[maxn], dp[maxn];

int main(int argc, char *argv[])
{
    // 数据输入，初始化
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i)
    {
        scanf("%d", &A[i]);
    }

    // 边界
    dp[0] = A[0];
    for (int i = 1; i < n; ++i)
    {
        // 状态转移方程
        dp[i] = max(A[i], dp[i - 1] + A[i]);
    }

    // 遍历 dp，输出最大值
    int res = 0;
    for (int i = 0; i < n; ++i)
    {
        if (dp[i] > res)
        {
            res = dp[i];
        }
    }
    printf("%d\n", res);

    return 0;
}

// 状态的无后效性：当前状态记录了历史信息，一旦当前状态确定，就不会再改变，且未来的决策只能在
// 已有的一个或若干个状态的基础上进行，历史信息只能通过已有的状态去影响未来的决策。

// 对动态规划问题来说，总会有很多设计状态的方式，但并不是所有状态都具有无后效性，
// 因此必须设计一个拥有无后效性的状态以及相应的状态转移方程，否则动态规划就没有办法得到正确的结果。

// 事实上，如何设计状态和状态转移方程，才是动态规划的核心，也是最难的地方。