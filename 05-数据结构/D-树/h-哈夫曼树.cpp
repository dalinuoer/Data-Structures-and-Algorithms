/**
 * @file h-哈夫曼树.cpp
 * @author Qin Hao (qinhao2020@foxmail.com)
 * @brief 
 * @version 0.1
 * @date 2021-02-10
 * 
 * @copyright Copyright (c) 2021 Qin Hao
 * 
 */

// ------ 1. 哈夫曼树 ------
/**
 * 合并果子问题
 * 有 n 堆果子，每堆果子的质量已知，现在需要把这些果子合并成一堆，但是每次只能把两堆果子合并到一起，
 * 同时会消耗与两堆果子质量之和等值的体力。显然，在进行 n - 1 次合并之后，就只剩下一堆了。
 * 为了尽可能节省体力，请设计出合并的次序方案，使得消耗的体力最少，并给出消耗的体力值。
 * 
 * 为了解决这个问题，不妨把每堆果子都看作节点，果堆的质量视作节点的权值，这样合并两个果堆的过程
 * 就可以看作给它们生成一个父节点，且父节点的权值等于它们两结点权值的和。于是把 n 堆果子合并成
 * 一堆的过程可以用一颗树来表示。
 * 
 * 事实上可以发现，消耗体力之和也可以通过把叶子结点的权值乘以它们各自的路径长度再求和来获得。
 * 其中叶子节点的路径长度是指从根节点出发到达该结点所经过的边数。
 * 把叶子节点的权值乘以其路径长度的结果称为这个叶子结点的带权路径长度。
 * 树的带权路径长度（Weighted Path Length of Tree，WPL）等于它所有叶子节点的带权路径长度之和。
 * 
 * 于是问题转换为：
 * 已知 n 个数，寻找一棵树，使得树的所有叶子节点的权值恰好为这 n 个数，并且使得这棵树的带权路径长度最小。
 * 
 * 带权路径长度最小的数被称为哈夫曼树（又称为最优二叉树）。
 * 显然，对同一组叶子节点来说，哈夫曼树可以不是唯一的，但是最小带权路径长度一定是唯一的。
 * 
 * 构造哈夫曼树的算法：
 * ① 初始状态下共有 n 个结点（节点的权值分别是给定的 n 个数），将它们视作 n 棵只有一个结点的树
 * ② 合并其中根节点权值最小的两棵树，生成两棵树根结点的父亲结点，权值为这两个根结点的权值之和，这样树的个数就少了一个
 * ③ 重复前面的步骤②，直到剩下一棵树为止，这棵树就是哈夫曼树。
 * 
 * 对哈夫曼树来说，不存在度为 1 的结点，并且权值越高的节点相对来说越接近根节点。
 * 
 * 哈夫曼树的构建思想就是：反复选择两个最小的元素，合并，直到只剩下一个元素。
 * 于是，一般可以使用优先队列（也可以说是堆结构）来执行这种策略。
 * 
 * 以合并果子问题为例，初始状态下将果堆的质量压入优先队列（小顶堆），之后每次从优先队列顶部取出两个最小的数，
 * 将它们相加并重新压入优先队列（需要在外部定义一个变量 ans 将相加的结果累加起来），重复直到优先队列
 * 中只剩下一个数，此时就得到了消耗的体力 ans，并且方案也可以在这个过程中得到。
 * 
 */
#include <cstdio>
#include <queue>
#include <vector>
using namespace std;

// 代表小顶堆的优先队列
priority_queue<long long, vector<long long>, greater<long long>> q;

int main()
{
    int n;
    long long temp, x, y, ans = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i)
    {
        scanf("%lld", &temp);
        q.push(temp); // 初始值压入优先队列
    }
    while (q.size() > 1) // 只要优先队列中至少有两个元素
    {
        x = q.top();
        q.pop();
        y = q.top();
        q.pop();
        q.push(x + y); // 取出堆顶两个元素，求和后压入优先队列
        ans += x + y; // 累计求和的结果
    }
    printf("%lld\n", ans);
    return 0;
}

// ------ 2. 哈夫曼编码 ------
/**
 * 对任意一棵二叉树来说，如果把二叉树上的所有分支都进行编号，将所有左分支都标记为 0，将所有右分支
 * 都标记为 1，那么对树上的任意一个节点，都可以根据从根节点出发到达它的分支顺序得到一个编号，
 * 并且这个编号是所有节点中唯一的。
 * 
 * 对任何一个非叶子节点，其编号一定是某个叶子节点编号的前缀，并且，对于任何一个叶子节点，其编号一定
 * 不会成为其他任何一个节点编号的前缀。
 * 
 * 考虑这样一个情景：假设现在有一个字符串，它由 A、B、C、D 这四个英文字母的一个或多个组成。
 * 现在希望把他编码成一个 01 串，方便进行数据传输。
 * 
 * 朴素的想法是使每个字母都用一个 01 串表示，然后拼接起来就可以。
 * 要求其中任何一个字符的编码都不是另一个字符的编码的前缀，否则就无法编码，把满足这种编码方式的
 * 编码称为前缀编码。前缀编码存在的意义在于不产生混淆，让解码能够正常进行。
 * 
 * 根据哈夫曼树的特点，只需要让这些字符作为一棵二叉树的叶子节点，就能产生需要的编码。
 * 
 * 进一步考虑，为了信息传递的效率尽可能高，需要尽量选取长度较短的编码方式。
 * 可以让出现频率高的字符优先使用短的编码，出现频率低的字符使用较长的编码。
 * 
 * 这种由哈夫曼树产生的编码方式称为哈夫曼编码，显然哈夫曼编码是能使给定字符串编码成 01 串后长度最短的前缀编码。
 * 
 * 最后强调，哈夫曼编码是针对确定的字符串来讲的。只有确定的字符串才能根据其中各字段出现的次数建立哈夫曼树，于是才有对应的哈夫曼编码。
 * 
 */

