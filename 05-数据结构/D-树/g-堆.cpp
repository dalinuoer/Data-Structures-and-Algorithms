/**
 * @file g-堆.cpp
 * @author Qin Hao (qinhao2020@foxmail.com)
 * @brief 
 * @version 0.1
 * @date 2021-02-10
 * 
 * @copyright Copyright (c) 2021 Qin Hao
 * 
 */

// ------ 1. 堆的定义与基本操作 ------
// 堆：堆是一棵完全二叉树，树中每个结点的值都不小于（或大于）其左右孩子结点的值。
// 大顶堆：如果父亲结点的值大于或等于孩子结点的值，那么称这样的堆为大顶堆，这时每个结点的值都是以它为根结点的子树的最大值。
// 小顶堆：如果父亲结点的值小于或等于孩子结点的值，那么称这样的堆为小顶堆，这时每个结点的值都是以它为根结点的子树的最小值。
// 堆的用途：对一般用于优先队列的实现，而优先队列默认情况下使用的是大顶堆。故下述讨论的都是大顶堆。

// --- 建堆 ---
// 对于一个对给定的初始序列，怎样把它建成一个堆呢？
// 对完全二叉树来说，比较简洁的实现方法是使用数组来存储。这样结点就按照层序存储于数组中，其中
// 第一个结点将存储于数组中的 1 号位，并且数组 i 号位表示的结点的左孩子就是 2i 号位，
// 而右孩子则是 2i+1 号位。
const int maxn = 100;
int heap[maxn], n = 10; // heap 为堆，n 为元素个数

// Step 1：按照初始序列的顺序把数据放入数组中

// Step 2：调整结点顺序，把结点从上往下调整
// 总是将当前结点 V 与它的左右孩子比较（如果有的话），假如孩子中存在权值比结点 V 的权值大的，
// 就将其中权值最大的那个孩子结点与结点 V 交换；交换完毕后继续让节点 V和孩子比较，直到结点 V 的
// 孩子的权值比结点 V 的权值小或是节点 V 不存在孩子节点。
void downAdjust(int low, int high) // 时间复杂度 O(logn)
{
    // 对 heap 数组在 [low, high] 范围进行向下调整
    // 其中 low 为欲调整结点的数组下标，high 一般为堆的最后一个元素的数组下标

    int i = low, j = i * 2; // i 为欲调整节点，j 为其左孩子
    while (j <= high) // 存在孩子节点
    {
        // 查找孩子节点中的最大权值
        if (j + 1 <= high && heap[j + 1] > heap[j]) // 如果右孩子存在，且右孩子的值大于左孩子
        {
            j = j + 1; // 让 j 储存右孩子下标
        }
        // 如果孩子中最大的权值比欲调整结点 i 大
        if (heap[j] > heap[i])
        {
            swap(heap[j], heap[i]); // 交换最大权值的孩子与欲调整节点 i
            i = j; // 保持 i 为欲调整节点，j 为 i 的左孩子
            j = i * 2;
        }
        else
        {
            break; // 孩子的权值均比欲调整节点 i 小，调整结束
        }
    }
}
// 假设序列中元素的个数为 n，由于完全二叉树的叶子结点个数为 （n/2）上取整 ,因此数组下标在 
// [1, (n/2)下取整] 范围内的节点都是非叶子节点。于是可以从 (n/2)下取整 号位开始倒着枚举结点，
// 对每个遍历到的节点 i 进行 [i, n] 范围内的调整。
// 为什么要倒着枚举？因为每次调整完一个节点后，当前子树中权值最大的节点就会处在根节点的位置，这样
// 当遍历其父亲结点时，就可以直接使用这个结果，也就是说，这种做法保证每个节点都是以其为根结点的
// 子树中的权值最大的节点。
void createHeap() // 时间复杂度 O(n)
{
    for (int i = n / 2; i >= 1; --i)
    {
        downAdjust(i, n);
    }
}

// --- 删除堆顶元素 ---
// 只需用最后一个元素覆盖堆顶元素，然后对根结点进行调整
void deleteTop() // 时间复杂度 O(logn)
{
    heap[1] = heap[n--]; // 用最后一个元素覆盖堆顶元素，并让元素个数减 1
    downAdjust(1, n); // 向下调整堆顶元素
}

// --- 添加元素 ---
// 可以把想要添加的元素放在数组最后，然后进行向上调整操作。
// 向上调整总是把欲调整节点与父亲结点比较，如果权值比父亲结点大，那么就交换其与父亲结点，这样反复
// 比较，直到达堆顶或是父亲结点的权值较大为止。
void upAdjust(int low, int high) // 时间复杂度 O(logn)
{
    // 对 heap 数组在 [low, high] 范围进行向上调整
    // 其中 low 一般设置为 1，high 表示欲调整结点的数组下标

    int i = high, j = i / 2; // i 为欲调整节点，j 为其父亲结点
    while (j >= low) // 父亲在 [low,high] 范围内
    {
        // 父亲结点的权值小于欲调整节点 i 的权值
        if (heap[j] < heap[i])
        {
            swap(heap[j], heap[i]); // 交换父亲和欲调整节点
            i = j; // 保持 i 为欲调整节点，j 为 i 的父亲
            j = i / 2;
        }
        else
        {
            break; // 父亲权值比欲调整节点 i 的权值大，调整结束
        }
    }
}

void insert(int x)
{
    heap[++n] = x; // 让元素个数加 1，然后数组末位赋值为 x
    upAdjust(1, n); // 向上调整加入的结点 n
}

// ------ 2. 堆排序 ------
// 堆排序是指使用堆结构对一个序列进行排序，此处讨论递增排序的情况。
// 考虑对一个堆来说，堆顶元素是最大的，因此在建堆完毕后，堆排序的直观思路就是取出堆顶元素，然后
// 将堆的最后一个元素替换至堆顶，再进行一次针对堆顶元素的向下调整————如此重复，直到堆中只有一个元素为止。

// 具体实现时，为了节省空间，可以倒着遍历数组，假设当前访问到 i 号位，那么将堆顶元素与 i 号位元素交换，
// 接着在 [1,i-1] 范围内对堆顶元素进行一次向下调整即可。

void heapSort() // 时间复杂度 O(nlogn)
{
    createHeap(); // 建堆
    for (int i = n; i > 1; --i) // 倒着枚举，直到堆中只有一个元素
    {
        // 交换堆顶与末尾，调整堆顶
        swap(heap[i], heap[1]);
        downAdjust(1, i - 1);
    }
}
