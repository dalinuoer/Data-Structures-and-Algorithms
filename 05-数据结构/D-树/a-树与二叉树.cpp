/**
 * @file a-树与二叉树.cpp
 * @author Qin Hao (qinhao2020@foxmail.com)
 * @brief 
 * @version 0.1
 * @date 2021-01-17
 * 
 * @copyright Copyright (c) 2021 Qin Hao
 * 
 */

// 1. 树与二叉树的相关概念

// 1.1. 树
// 概念：
// 结点、根节点、叶子节点、边、子节点、子树
// 孩子结点、父亲结点、兄弟结点、祖先结点、子孙结点

// 注意：如果存在一条从结点 X 到结点 Y 的从上至下的路径，那么称结点 X 是结点 Y 的祖先结点，Y 是 X 的子孙结点。
//      自己既是自己的祖先结点，也是自己的子孙结点。

// 性质：
// ① 树可以没有结点，这种情况下把树称为 “空树”；
// ② 树的层次从根节点开始算起，即根结点为第一层，根结点子树的根结点为第二层，以此类推；
// ③ 把结点的子树棵树称为结点的 度，而树中结点的最大的度称为树的 度（宽度）；
// ④ 由于一条边连接两个结点，且树中不存在环，因此对有 n 个结点的树，边数一定是 n-1，且满足连通、
//   边数等于顶点数减 1 的结构一定是一棵树；
// ⑤ 叶子结点被定义为度为 0 的结点，因此当树中只有一个结点，即根结点时，根结点也算作叫叶子节点；
// ⑥ 结点的深度是指从根结点（深度为 1）开始自顶向下逐层累加至该结点时的深度值；
//   结点的高度是指从最底层叶子结点（高度为 1）开始自底向上逐层累加至该结点时的高度值。
//   树的深度是指树中结点的最大深度，树的高度是指树中结点的最大高度。
//   对树而言，深度和高度是相等的。但是具体到某个结点，深度和高度就不一定相等了。
// ⑦ 多棵树组合在一起称为森林，即森林是若干棵树的集合。

// 1.2. 二叉树的递归定义
// 要么二叉树没有根结点，是一颗空树；要么二叉树由根结点、左子树、右子树组成，且左子树和右子树都是二叉树。

// 注意：区分二叉树与度为 2 的树
// 对树来说，结点的子树是不区分左右顺序的，因此度为 2 的树只能说明树中每个结点的子结点个数不超过 2.
// 而二叉树虽然也满足每个结点的子结点个数不超过 2，但它的左右子树是严格区分的，不能随意交换左右子树的位置。
// 这就是二叉树与度为 2 的树的主要区别。

// 两种特殊的二叉树
// ① 满二叉树：每一层的结点个数都达到了当层能达到的最大结点数。
// ② 完全二叉树：除了最下面一层之外，其余层的结点数都达到了当层能达到的最大结点数，且最下面一
//   层只从左至右连续存在若干结点，而这些连续结点右边的结点全部不存在。

// 1.3. 二叉树的存储结构与基本操作
// 存储结构：二叉链表。与普通链表的区别在于，指针域有两个，分别指向左子树的根结点和右子树的根结点。

// 完全二叉树除了可以使用二叉链表存储外，还可使用数组。
// 对完全二叉树当中的任何一个结点（设编号为 x），其左孩子的编号一定是 2x，右孩子的编号一定是 2x+1.
// 也就是说，完全可以使用一个大小为 2^k 的数组来存放所有结点信息，k 为完全二叉树的最大高度，且 1 号位存放的必须是根结点
// 事实上，就算不是完全二叉树，也可以把它视作完全二叉树来存储，但是比较浪费空间

// 该数组中元素存放的顺序恰好为该完全二叉树的层序遍历序列。
// 判断某个结点是否为叶结点的标志为：该结点（记下标为 root）的左子节点的编号 root*2 大于结点总个数 n；
// 判断某个结点是否为空结点的标志：该结点下标 root 大于结点总数 n。
struct node
{
    typename data; // 数据域
    node *lchild;  // 指向左子树根结点的指针
    node *rchild;  // 指向右子树根结点的指针
};
node *root = nullptr;

// 新建结点
node *newNode(int v)
{
    node *Node = new node;
    Node->data = v;
    Node->lchild = Node->rchild = nullptr;
    return Node;
}

// 查找、修改
void search(node *root, int x, int newdata)
{
    if (root == nullptr) // 空树，死胡同（递归边界）
    {
        return;
    }
    if (root->data == x)
    {
        root->data = newdata;
    }
    // 往左/右子树搜索（递归式）
    search(root->lchild, x, newdata);
    search(root->rchild, x, newdata);
}

// 插入
// 二叉树结点的插入位置就是数据域在二叉树中查找失败的位置
// 注意根结点指针 root 需使用引用，否则插入不会成功
void insert(node *&root, int x)
{
    if (root == nullptr) // 空树，说明查找失败，也即插入位置（递归边界）
    {
        root = newNode(x);
        return;
    }
    if (由二叉树性质，x 应该插在左子树)
    {
        insert(root->lchild, x); // 往左子树搜索（递归式）
    }
    else
    {
        insert(root->rchild, x); // 往右子树搜索
    }
}

// 一般来说，如果函数中需要新建结点，即对二叉树的结构作出修改，就需要加引用；
// 如果只是修改当前已有结点的内容，或仅仅是遍历树，就不需要加引用。

// 在新建结点之后，务必令新结点的左右指针域为 nullptr，表示这个新节点暂时没有左右子树。

// 创建
// 其实就是二叉结点的插入过程
node *create(int data[], int n)
{
    node *root = nullptr;
    for (int i = 0; i < n; ++i)
    {
        insert(root, data[i]);
    }
    return root;
}
