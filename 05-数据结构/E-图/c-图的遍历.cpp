/**
 * @file c-图的遍历.cpp
 * @author Qin Hao (qinhao2020@foxmail.com)
 * @brief 
 * @version 0.1
 * @date 2021-02-11
 * 
 * @copyright Copyright (c) 2021 Qin Hao
 * 
 */

// ------ 1. 采用深度优先搜索（DFS）法遍历图
// 沿着一条路径直到无法继续前进，才退回到路径上离当前顶点最近的还存在未访问分支顶点的岔道口，
// 并前往访问那些未访问分支节点，直到遍历完整个屯。

// ① 连通分量：在无向图中，如果两个顶点之间可以相互到达，那么就称这两个顶点连通。
// 如果图的任意两个顶点都连通，则称图为连通图；否则，称图为非连通图，且称其中的极大连通子图为连通分量。

// ② 强连通分量：在有向图中，如果两个顶点可以各自通过一条有向路径到达另一个顶点，就称这两个顶点强连通。
// 如果图的任意两个顶点都强连通，则称图为强连通图；否则，称图为非强连通图，且称其中的极大强连通子图为强连通分量。

// 为了方便叙述，下面把连通分量和强连通分量都称为连通块。

// DFS 遍历的基本思路就是：将经过的顶点设置为已访问，在下次递归碰到这个顶点时就不再去处理，直到整个图的顶点都被标记为已访问。
// 伪代码：
DFS(u) // 访问顶点 u
{
    vis[u] = true; // 设置顶点 u 已被访问
    for (从 u 出发能到达的所有顶点 v)
    {
        if (vis[v] == false) // 顶点 v 未被访问
        {
            DFS(v); // 递归访问 v
        }
    }
}
DFSTrave(G) // 遍历图 G
{
    for (G 的所有顶点 u)
    {
        if (vis[u] == false) // 未被访问
        {
            DFS(u); // 访问 u 所在的连通块
        }
    }
}

// ------ 2. 采用广度优先搜索（BFS）法遍历图
// 伪代码：
BFS(u) // 遍历 u 所在的连通块
{
    queue q;
    将 u 入队；
    inq[u] = true; // 设置 u 已被加入过队列
    while (q 非空)
    {
        取出 q 的队首元素 u 进行访问；
        for (从 u 出发可达的所有顶点 v)
        {
            if (inq[v] == false)
            {
                将 v 入队；
                inq[v] = true; // 设置 v 已被加入过队列
            }
        }
    }
}

BFSTrave(G) // 遍历图 G
{
    for (G 的所有顶点 u)
    {
        if (inq[u] == false)
        {
            BFS(u); // 遍历 u 所在的连通块
        }
    }
}

// 与树的 BFS 遍历一样，在给定 BFS 初始点的情况下，可能需要输出该连通块内所有其他顶点的层号，
// 这时只需要修改少量内容即可达到要求。