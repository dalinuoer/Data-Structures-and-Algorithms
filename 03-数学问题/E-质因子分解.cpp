/*
* 质因子分解
* Author: Qin Hao
* Date: 2020/9/24
* Note: Happy birthday to me!
*/

// 质因子分解指一个正整数n写成一个或多个质数的乘积的形式
// 1既不是质数也不是合数，如果有题目要求对1进行处理，那么视题目条件而定来进行特判处理

// 可使用打表事先求出某范围内的素数表

// 由于每个质因子都可以出现不止一次，因此不妨定义结构体factor，用来存放质因子及其个数
struct factor {
    int x, cnt; // x为质因子，cnt为其个数
} fac[10];
// 考虑到2*3*5*7*11*13*17*19*23*29就已经超过int范围，因此对一个int型范围的数来说，fac
// 数组的大小只需要开到10就可以了

// 对一个正整数n来说，如果它存在[2, n]范围内的质因子，要么这些质因子全部小于等于sqrt(n)
// 要么只存在一个大于sqrt(n)的质因子，而其余质因子全部小于等于sqrt(n)

// 1. 枚举1~sqrt(n)范围内的所有质因子p，判断p是否是n的因子
// 若是，那么给fac数组中增加质因子p，并初始化其个数为0.然后，只要p还是n的因子，就让n不断
// 除以p，每次操作令p的个数加1，直到p不再是n的因子为止。
if (n % prime[i] == 0) {
    fac[num].x = prime[i];
    fac[num].cnt = 0;
    while (n % prime[i] == 0) {
        ++fac[num].cnt;
        n /= prime[i];
    }
    ++num;
}
// 2. 若在上述步骤结束后n仍然大于1，说明只存在一个大于sqrt(n)的质因子（可能是n本身），
// 此时需要把这个质因子加入fac数组，并令其个数为1.
if (n != 1) {
    fac[num].x = n;
    fac[num++].x = 1;
}

// 时间复杂度为 O(根号n)